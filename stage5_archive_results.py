# -*- coding: utf-8 -*-
"""
Stage 5: Archive Results

This script performs the final archiving stage of the data synchronization process.
It locates the output directory for the specified document source generated by
previous stages, creates a timestamped zip archive of its contents, and saves
it to a designated archive folder on the NAS.

Workflow:
1.  Checks if a skip flag exists from Stage 1. If yes, exits gracefully.
2.  Defines the source directory on NAS containing results for the DOCUMENT_SOURCE.
3.  Defines the target archive directory on NAS (_archive).
4.  Ensures the target archive directory exists.
5.  Creates a local temporary directory.
6.  Recursively downloads the contents of the source NAS directory to the local temp dir.
7.  Creates a timestamped zip archive locally from the downloaded contents.
8.  Uploads the local zip archive to the target NAS archive directory.
9.  Cleans up the local temporary directory.
"""

import os
import sys
import smbclient
import shutil
import tempfile
from datetime import datetime

# ==============================================================================
# --- Configuration ---
# ==============================================================================

# --- NAS Configuration (Should match previous stages or be loaded) ---
# IMPORTANT: Replace placeholder values if not loaded from a shared config.
NAS_PARAMS = {
    "ip": "your_nas_ip",          # Replace with NAS IP address
    "share": "your_share_name",   # Replace with NAS share name
    "user": "your_nas_user",      # Replace with NAS username
    "password": "your_nas_password" # Replace with NAS password
}
# Base path on the NAS share where Stage 1-4 output files were stored.
NAS_OUTPUT_FOLDER_PATH = "path/to/your/output_folder" # From previous stages

# --- Processing Configuration ---
# Define the specific document source processed in previous stages.
DOCUMENT_SOURCE = 'internal_esg' # From previous stages
ARCHIVE_SUBFOLDER_NAME = '_archive' # Name of the subfolder for archives

# ==============================================================================
# --- Helper Functions ---
# ==============================================================================

def initialize_smb_client():
    """Sets up smbclient credentials."""
    try:
        smbclient.ClientConfig(username=NAS_PARAMS["user"], password=NAS_PARAMS["password"])
        print("SMB client configured successfully.")
        return True
    except Exception as e:
        print(f"[ERROR] Failed to configure SMB client: {e}")
        return False

def create_nas_directory(smb_dir_path):
    """Creates a directory on the NAS if it doesn't exist."""
    try:
        if not smbclient.path.exists(smb_dir_path):
            print(f"   Creating NAS directory: {smb_dir_path}")
            smbclient.makedirs(smb_dir_path, exist_ok=True)
            print(f"   Successfully created directory.")
        else:
            # print(f"   NAS directory already exists: {smb_dir_path}") # Optional: reduce verbosity
            pass
        return True
    except smbclient.SambaClientError as e:
        print(f"   [ERROR] SMB Error creating/accessing directory '{smb_dir_path}': {e}")
        return False
    except Exception as e:
        print(f"   [ERROR] Unexpected error creating/accessing NAS directory '{smb_dir_path}': {e}")
        return False

def download_directory_from_nas(smb_source_dir, local_dest_dir):
    """Recursively downloads a directory from NAS to a local path."""
    print(f" -> Attempting to download from NAS: {smb_source_dir} to Local: {local_dest_dir}")
    files_downloaded = 0
    errors = 0
    try:
        if not smbclient.path.isdir(smb_source_dir):
            print(f"   [ERROR] Source NAS path is not a directory or does not exist: {smb_source_dir}")
            return False

        # Ensure the base local destination directory exists
        os.makedirs(local_dest_dir, exist_ok=True)

        for dirpath, dirnames, filenames in smbclient.walk(smb_source_dir):
            # Calculate the relative path from the source base
            relative_dir = os.path.relpath(dirpath, smb_source_dir)
            if relative_dir == '.':
                relative_dir = '' # Avoid './' prefix in local path

            # Create corresponding local directories
            local_current_dir = os.path.join(local_dest_dir, relative_dir)
            os.makedirs(local_current_dir, exist_ok=True)

            # Download files in the current directory
            for filename in filenames:
                smb_file_path = os.path.join(dirpath, filename).replace('\\', '/')
                local_file_path = os.path.join(local_current_dir, filename)
                try:
                    # print(f"      Downloading: {smb_file_path} -> {local_file_path}") # Verbose
                    with smbclient.open_file(smb_file_path, mode='rb') as nas_f:
                        with open(local_file_path, 'wb') as local_f:
                            shutil.copyfileobj(nas_f, local_f) # Efficient copy
                    files_downloaded += 1
                except smbclient.SambaClientError as e:
                    print(f"      [ERROR] SMB Error downloading file '{smb_file_path}': {e}")
                    errors += 1
                except Exception as e:
                    print(f"      [ERROR] Unexpected error downloading file '{smb_file_path}': {e}")
                    errors += 1

        print(f" <- Finished download. Files downloaded: {files_downloaded}, Errors: {errors}")
        return errors == 0 # Return True if no errors occurred

    except smbclient.SambaClientError as e:
        print(f"   [ERROR] SMB Error walking source directory '{smb_source_dir}': {e}")
        return False
    except Exception as e:
        print(f"   [ERROR] Unexpected error downloading directory '{smb_source_dir}': {e}")
        return False

def upload_file_to_nas(local_file_path, smb_dest_path):
    """Uploads a local file to a NAS path."""
    print(f"   Attempting to upload Local: {local_file_path} to NAS: {smb_dest_path}")
    try:
        # Ensure the destination directory exists on NAS
        smb_dest_dir = os.path.dirname(smb_dest_path)
        if not create_nas_directory(smb_dest_dir):
            print(f"   [ERROR] Failed to ensure destination directory exists: {smb_dest_dir}")
            return False

        with open(local_file_path, 'rb') as local_f:
            with smbclient.open_file(smb_dest_path, mode='wb') as nas_f:
                shutil.copyfileobj(local_f, nas_f) # Efficient copy
        print(f"   Successfully uploaded to: {smb_dest_path}")
        return True
    except smbclient.SambaClientError as e:
        print(f"   [ERROR] SMB Error uploading file to '{smb_dest_path}': {e}")
        return False
    except FileNotFoundError:
        print(f"   [ERROR] Local file not found: {local_file_path}")
        return False
    except Exception as e:
        print(f"   [ERROR] Unexpected error uploading file '{local_file_path}': {e}")
        return False

# ==============================================================================
# --- Main Execution Logic ---
# ==============================================================================

if __name__ == "__main__":
    print("\n" + "="*60)
    print(f"--- Running Stage 5: Archive Results ---")
    print(f"--- Document Source: {DOCUMENT_SOURCE} ---")
    print("="*60 + "\n")

    # --- Initialize SMB Client ---
    print("[1] Initializing SMB Client...")
    if not initialize_smb_client():
        sys.exit(1)
    print("-" * 60)

    # --- Define NAS Paths ---
    print("[2] Defining NAS Paths...")
    # Source directory containing results for the specific document source
    source_dir_relative = os.path.join(NAS_OUTPUT_FOLDER_PATH, DOCUMENT_SOURCE).replace('\\', '/')
    source_dir_smb = f"//{NAS_PARAMS['ip']}/{NAS_PARAMS['share']}/{source_dir_relative}"

    # Base archive directory (one level up from source-specific, then into _archive)
    archive_base_dir_relative = os.path.join(NAS_OUTPUT_FOLDER_PATH, ARCHIVE_SUBFOLDER_NAME).replace('\\', '/')
    archive_base_dir_smb = f"//{NAS_PARAMS['ip']}/{NAS_PARAMS['share']}/{archive_base_dir_relative}"

    print(f"   Source Directory to Archive (SMB): {source_dir_smb}")
    print(f"   Target Archive Directory (SMB): {archive_base_dir_smb}")
    print("-" * 60)

    # --- Ensure Archive Directory Exists ---
    print(f"[3] Ensuring Target Archive Directory Exists on NAS: {archive_base_dir_smb}") # Renumbered step
    if not create_nas_directory(archive_base_dir_smb):
        print(f"[CRITICAL ERROR] Failed to create or access target archive directory. Exiting.")
        sys.exit(1)
    print("-" * 60)

    # --- Create Local Temporary Directory ---
    print("[4] Creating Local Temporary Directory...") # Renumbered step
    temp_dir_local = tempfile.mkdtemp(prefix=f"stage5_archive_{DOCUMENT_SOURCE}_")
    print(f"   Local Temp Directory: {temp_dir_local}")
    print("-" * 60)

    # --- Download Source Directory Contents ---
    print(f"[6] Downloading contents from {source_dir_smb} to {temp_dir_local}...")
    # Define a subdirectory within temp_dir_local to hold the actual contents,
    # so the zip file doesn't contain an extra top-level temp folder name.
    local_download_target = os.path.join(temp_dir_local, DOCUMENT_SOURCE)
    download_success = download_directory_from_nas(source_dir_smb, local_download_target)

    if not download_success:
        print(f"[ERROR] Failed to download all contents from {source_dir_smb}. Archiving may be incomplete or fail.")
        # Decide whether to proceed or exit. Let's proceed but log the error.
        # Optionally: shutil.rmtree(temp_dir_local); sys.exit(1)
    print("-" * 60)

    # --- Create Zip Archive ---
    print("[5] Creating Local Zip Archive...") # Renumbered step
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_filename_base = f"{DOCUMENT_SOURCE}_{timestamp}"
    # Place the zip file directly inside temp_dir_local, not inside the downloaded content folder
    local_zip_path_base = os.path.join(temp_dir_local, zip_filename_base) # Path without .zip extension for make_archive

    try:
        # shutil.make_archive will create 'zip_filename_base.zip'
        # It zips the contents of 'local_download_target'
        # The archive will contain the 'DOCUMENT_SOURCE' folder and its contents
        print(f"   Archiving contents of: {local_download_target}")
        print(f"   Creating archive base name: {local_zip_path_base}")
        final_zip_local_path = shutil.make_archive(
            base_name=local_zip_path_base, # Output path without extension
            format='zip',                  # Archive format
            root_dir=temp_dir_local,       # Directory containing the folder to zip
            base_dir=DOCUMENT_SOURCE       # The folder *within* root_dir to zip
        )
        print(f"   Successfully created local zip archive: {final_zip_local_path}")
    except Exception as e:
        print(f"[CRITICAL ERROR] Failed to create local zip archive: {e}")
        shutil.rmtree(temp_dir_local) # Clean up temp dir
        sys.exit(1)
    print("-" * 60)

    # --- Upload Zip Archive to NAS ---
    print(f"[6] Uploading Zip Archive to NAS Archive Directory: {archive_base_dir_smb}") # Renumbered step
    zip_filename = os.path.basename(final_zip_local_path)
    target_zip_smb_path = os.path.join(archive_base_dir_smb, zip_filename).replace('\\', '/')

    upload_success = upload_file_to_nas(final_zip_local_path, target_zip_smb_path)
    if not upload_success:
        print(f"[CRITICAL ERROR] Failed to upload zip archive to NAS. Local archive kept at: {final_zip_local_path}")
        # Don't delete local temp dir in this case, so user can retrieve the zip
        sys.exit(1)
    print("-" * 60)

    # --- Cleanup Local Temporary Directory ---
    print("[7] Cleaning Up Local Temporary Directory...") # Renumbered step
    try:
        shutil.rmtree(temp_dir_local)
        print(f"   Successfully removed local temp directory: {temp_dir_local}")
    except Exception as e:
        print(f"   [WARNING] Failed to remove local temp directory {temp_dir_local}: {e}")
    print("-" * 60)

    print("\n" + "="*60)
    print(f"--- Stage 5 Completed Successfully ---")
    print(f"--- Results archived to: {target_zip_smb_path} ---")
    print("="*60 + "\n")
